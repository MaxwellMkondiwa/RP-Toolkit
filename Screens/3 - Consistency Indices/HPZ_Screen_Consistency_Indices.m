function [Graph_flags, power_test_settings, GARP_flags, AFRIAT_flags, VARIAN_flags, HOUTMAN_flags, MPI_flags, ok] = HPZ_Screen_Consistency_Indices(main_folder, runs_counter, pref_class, num_of_goods)  

% this function creates a user interface screen from which the user chooses
% which of the consistency and inconsistency measures to be calculated, and
% also if to calculate the residuals for each observation, and also if to
% calculate the residuals using an "in sample" approach or an "out of sample"
% approach.

% for detailed explanations about input/output variables that possess
% the same name and meaning in multiple functions (e.g. data, action_flag, 
% pref_class, etc.) see: HPZ_Variables_Documentation in the "Others" sub-folder 


% read the saved settings for this screen
[Graph_flags, power_test_settings, GARP_flags, AFRIAT_flags, VARIAN_flags, HOUTMAN_flags, MPI_flags] = HPZ_Consistency_Indices_Settings_Read(main_folder);
power_test_num_simulations_str = num2str(power_test_settings(2));

% making sure at least one aggregator of Varian is marked
if sum(VARIAN_flags(5:7)) == 0
    VARIAN_flags(5) = 1;
end

% this little cell helps us to convert 0 and 1 to 'off' and 'on', respectively 
enable = {'off','on'};



%% location and size parameters (use these to easily make changes to the screen)

% screen size
figure_width = 1030;
figure_height = 665;
% limit of height as percentage of computer screen height
max_height_percent = HPZ_Constants.max_height_percent;

% height of bottom space designated for OK and Cancel buttons
buttons_space_height = 50;
% buttons height as percentage of the space they are in
buttons_height = 0.6;
% the distant between a button to the edge of the screen,
% and is also half the distance between buttons.
% the size of the buttons is designed to fit this and the buttons_height 
% and the width of the screen
buttons_dists = 10;
% number of buttons
buttons_num = 2;

% width of each element
element_width = 280;
% normal_width for a sub element
sub_element_width = 80;

% relative location of elements:
% how much the right part should be offset to the right in comparison to the left part 
move_right = element_width + 60;
% how much distance between parts (different indices) that are one below each other 
move_down = 20;

% helper for small extra distance when needed
extra_dist = 10;

% distance of highest element from top
top_dist = 10;

% distance of the labels from the left
left_label = 15;
% distance of other elements from the left
left_other = 45;

% sizes of labels used in the head of each section
label_width = 300;
label_height = 30;

% height of elements that allows to used to type in a number
text_height = 20;

% each radio options will be with height 25
% an element with X radio options one below another will be of height 25X + 15  
% a "yes-no" element (except for the special ones in VARIAN and HM) with X radio options one right to another may be of height 35 + 15 
radio_height = 20;
radio_label = 25;
radio_yes_no = 35;
% distance of bottom radio option from the bottom
radio_bottom = 5;
% offset to the right of radio options that are vertical
radio_offset = 15;
radio_small_offset = 5;
% offsets to the right of yes/no horizontal radio options
yes_no_offsets = [25 , 150];

% font size of label
label_font_size = 12;
% general font size
font_size = 8;
% general but bigger font size
big_font_size = 10;





%% create the figure, with a slider if needed
% scroll bar width (if scroll is needed)
scroll_width = 20;
bottom_space_height = buttons_space_height;
top_space_height = 0;
panel_height = figure_height - bottom_space_height - top_space_height;
figure_title = char(strcat('Inconsistency Indices (', HPZ_Constants.current_run_screen, {' '}, num2str(runs_counter), ')'));
[fh , panel] = ui_scroll_screen(figure_width, figure_height, scroll_width, max_height_percent, top_space_height, bottom_space_height, figure_title);

% width including scroll bar if there is one
pos = get(fh,'position');
full_width = pos(3);



%% Revealed preference Graph per Subject
% current bottom coordinate
current_bottom = panel_height-top_dist-label_height;
label_GARP = uicontrol('Parent',panel, ...
    'style','text', ...
    'units','pix', ...
    'position',[left_label , current_bottom , label_width , label_height], ...
    'backgroundc',get(fh,'color'), ...
    'fontsize',label_font_size,'fontweight','bold', ...
    'HorizontalAlignment','left', ...
    'string','Revealed Preference Graphs'); %#ok<NASGU>

% current height of element
current_height = 4*radio_label+radio_label;
% current bottom coordinate
current_bottom = current_bottom - current_height;
RP_Graph = uibuttongroup('Parent',panel, 'units','pix', ...
    'title', 'Create and Save Revealed Preference Graph Per Subject', ...
    'fontsize',font_size, ...
    'pos',[left_other-20 , current_bottom , element_width+40 , current_height]);

RP_Graph_choice(1) = uicontrol(RP_Graph, ...
    'value',Graph_flags(1), ...
    'enable',enable{2}, ...
    'style','check', ...
    'unit','pix', ...
    'position',[radio_small_offset , 3*radio_label , element_width+40 , radio_yes_no], ...
    'fontsize',font_size, ...
    'string',' Preference Hierarchy with bundles (if consistent)');
RP_Graph_choice(2) = uicontrol(RP_Graph, ...
    'value',Graph_flags(2), ...
    'enable',enable{2}, ...
    'style','check', ...
    'unit','pix', ...
    'position',[radio_small_offset , 2*radio_label , element_width+40 , radio_yes_no], ...
    'fontsize',font_size, ...
    'string',' Preference Hierarchy with observation numbers (if consistent)');
RP_Graph_choice(3) = uicontrol(RP_Graph, ...
    'value',Graph_flags(3), ...
    'enable',enable{2}, ...
    'style','check', ...
    'unit','pix', ...
    'position',[radio_small_offset , radio_label , element_width+40 , radio_yes_no], ...
    'fontsize',font_size, ...
    'string',' Preference Relations involved in cycles (if inconsistent)');
RP_Graph_choice(4) = uicontrol(RP_Graph, ...
    'value',Graph_flags(4), ...
    'enable',enable{2}, ...
    'style','check', ...
    'unit','pix', ...
    'position',[radio_small_offset , 0 , element_width+40 , radio_yes_no], ...
    'fontsize',font_size, ...
    'string',' Preference Relations involved in minimal cycles (if inconsistent)');

% help button
RP_Graph_help_button_1 = uicontrol('Parent',panel, 'style','push', ...
    'unit','pix', ...
    'position',[left_other+element_width-3 , current_bottom+current_height-30 , 20 , 20], ...
    'string','?', ...
    'fontsize',big_font_size, ...
    'callback',{@help_button_1_call}); %#ok<NASGU>

% current height of element
current_height = 2*radio_label+radio_label;
% current bottom coordinate
current_bottom = current_bottom - current_height;
RP_Graph_option = uibuttongroup('Parent',panel, 'units','pix', ...
    'title', 'Options', ...
    'fontsize',font_size, ...
    'pos',[left_other-20 , current_bottom , element_width+40 , current_height]);
RP_Graph_options(1) = uicontrol(RP_Graph_option, ...
    'value',(Graph_flags(5)==0)*1, ...
    'enable',enable{2}, ...
    'style','rad', ...
    'unit','pix', ...
    'position',[radio_small_offset , radio_label , element_width+40 , radio_yes_no], ...
    'fontsize',font_size, ...
    'string',' No weights on edges; Strict = thick line , Weak = thin line');
RP_Graph_options(2) = uicontrol(RP_Graph_option, ...
    'value',(Graph_flags(5)==1)*1, ...
    'enable',enable{2}, ...
    'style','rad', ...
    'unit','pix', ...
    'position',[radio_small_offset , 0 , element_width+40 , radio_yes_no], ...
    'fontsize',font_size, ...
    'string',' Weight = 1-v');

% help button
RP_Graph_help_button_2 = uicontrol('Parent',panel, 'style','push', ...
    'unit','pix', ...
    'position',[left_other+element_width-3 , current_bottom+current_height-30 , 20 , 20], ...
    'string','?', ...
    'fontsize',big_font_size, ...
    'callback',{@help_button_2_call}); %#ok<NASGU>

%% GARP WARP and SARP settings
% current bottom coordinate
current_bottom = current_bottom - move_down - label_height;
label_GARP = uicontrol('Parent',panel, ...
    'style','text', ...
    'units','pix', ...
    'position',[left_label , current_bottom , label_width , label_height], ...
    'backgroundc',get(fh,'color'), ...
    'fontsize',label_font_size,'fontweight','bold', ...
    'HorizontalAlignment','left', ...
    'string','GARP, WARP and SARP violations'); %#ok<NASGU>

%% calculate GARP WARP and SARP or not
% current bottom coordinate
current_bottom = current_bottom - (radio_yes_no+radio_label);
calculate_GARP = uibuttongroup('Parent',panel, 'units','pix', ...
    'title', 'Calculate', ...
    'fontsize',font_size, ...
    'pos',[left_other , current_bottom , element_width , radio_yes_no+radio_label]);

calculate_GARP_choice(1) = uicontrol(calculate_GARP, ...
    'value',GARP_flags(1), ...
    'enable','on', ...
    'style','rad', ...
    'unit','pix', ...
    'position',[yes_no_offsets(1) , radio_bottom , sub_element_width , radio_yes_no], ...
    'fontsize',font_size, ...
    'string',' YES');
calculate_GARP_choice(2) = uicontrol(calculate_GARP, ...
    'value',1-GARP_flags(1), ...
    'enable','on', ...
    'style','rad', ...
    'unit','pix', ...
    'position',[yes_no_offsets(2) , radio_bottom , sub_element_width , radio_yes_no], ...
    'fontsize',font_size, ...
    'string',' NO');

%% With or Without residuals
enable_temp = enable{GARP_flags(1)+1};
% current height of element
current_height = radio_yes_no+radio_label;
% current bottom coordinate
current_bottom = current_bottom - current_height;
residual_GARP = uibuttongroup('Parent',panel, 'units','pix', ...
    'title', 'Residuals', ...
    'fontsize',font_size, ...
    'pos',[left_other , current_bottom , element_width , current_height]);

residual_GARP_choice(1) = uicontrol(residual_GARP, ...
    'value',GARP_flags(2), ...
    'enable',enable_temp, ...
    'style','rad', ...
    'unit','pix', ...
    'position',[yes_no_offsets(1) , radio_bottom , sub_element_width , radio_yes_no], ...
    'fontsize',font_size, ...
    'string',' YES');
residual_GARP_choice(2) = uicontrol(residual_GARP, ...
    'value',1-GARP_flags(2), ...
    'enable',enable_temp, ...
    'style','rad', ...
    'unit','pix', ...
    'position',[yes_no_offsets(2) , radio_bottom , sub_element_width , radio_yes_no], ...
    'fontsize',font_size, ...
    'string',' NO');

%% In Sample and/or Out Of Sample
enable_temp = enable{(GARP_flags(1)&&GARP_flags(2))+1};
% current height of element
current_height = 3*radio_height+radio_label;
% current bottom coordinate
current_bottom = current_bottom - current_height;
residual_GARP_options_group = uibuttongroup('Parent',panel, 'units','pix', ...
    'title', 'Options', ...
    'fontsize',font_size, ...
    'pos',[left_other , current_bottom , element_width , current_height]);
residual_GARP_options(1) = uicontrol(residual_GARP_options_group, ...
    'value',(GARP_flags(3) && ~GARP_flags(4)), ...
    'enable',enable_temp, ...
    'style','rad', ...
    'unit','pix', ...
    'position',[radio_offset , radio_bottom+2*radio_height , element_width , radio_height], ...
    'string',' In Sample Calculation', ...
    'fontsize',big_font_size);
residual_GARP_options(2) = uicontrol(residual_GARP_options_group, ...
    'value',(~GARP_flags(3) && GARP_flags(4)), ...
    'enable',enable_temp, ...
    'style','rad', ...
    'unit','pix', ...
    'position',[radio_offset , radio_bottom+1*radio_height , element_width , radio_height], ...
    'string',' Out of Sample Calculation', ...
    'fontsize',big_font_size);
residual_GARP_options(3) = uicontrol(residual_GARP_options_group, ...
    'value',(GARP_flags(3) && GARP_flags(4)), ...
    'enable',enable_temp, ...
    'style','rad', ...
    'unit','pix', ...
    'position',[radio_offset , radio_bottom+0*radio_height , element_width , radio_height], ...
    'string',' Both', ...
    'fontsize',big_font_size);

%% Which residuals to print - WARP / GARP / SARP / All
enable_temp = enable{(GARP_flags(1)&&GARP_flags(2))+1};
% current height of element
current_height = 4*radio_height+radio_label;
% current bottom coordinate
current_bottom = current_bottom - current_height;
which_residual_GARP_options_group = uibuttongroup('Parent',panel, 'units','pix', ...
    'title', 'Which residuals to print', ...
    'fontsize',font_size, ...
    'pos',[left_other , current_bottom , element_width , current_height]);
which_residual_GARP_options(1) = uicontrol(which_residual_GARP_options_group, ...
    'value',(GARP_flags(5) && ~GARP_flags(6) && ~GARP_flags(7)), ...
    'enable',enable_temp, ...
    'style','rad', ...
    'unit','pix', ...
    'position',[radio_offset , radio_bottom+3*radio_height , element_width , radio_height], ...
    'string',' WARP', ...
    'fontsize',big_font_size);
which_residual_GARP_options(2) = uicontrol(which_residual_GARP_options_group, ...
    'value',(~GARP_flags(5) && GARP_flags(6) && ~GARP_flags(7)), ...
    'enable',enable_temp, ...
    'style','rad', ...
    'unit','pix', ...
    'position',[radio_offset , radio_bottom+2*radio_height , element_width , radio_height], ...
    'string',' GARP', ...
    'fontsize',big_font_size);
which_residual_GARP_options(3) = uicontrol(which_residual_GARP_options_group, ...
    'value',(~GARP_flags(5) && ~GARP_flags(6) && GARP_flags(7)), ...
    'enable',enable_temp, ...
    'style','rad', ...
    'unit','pix', ...
    'position',[radio_offset , radio_bottom+1*radio_height , element_width , radio_height], ...
    'string',' SARP', ...
    'fontsize',big_font_size);
which_residual_GARP_options(4) = uicontrol(which_residual_GARP_options_group, ...
    'value',(GARP_flags(5) && GARP_flags(6) && GARP_flags(7)), ...
    'enable',enable_temp, ...
    'style','rad', ...
    'unit','pix', ...
    'position',[radio_offset , radio_bottom+0*radio_height , element_width , radio_height], ...
    'string',' All', ...
    'fontsize',big_font_size);


set(calculate_GARP_choice(:),'callback',{@GARP_calc_call})  % Set callback.
set(residual_GARP_choice(:),'callback',{@GARP_rd_call})     % Set callback.

%% End of GARP WARP and SARP settings





%% MPI settings
% MPI will be ready for the next version (version 3), currently not implemented 
% % current bottom coordinate (MPI is just below GARP)
% current_bottom = current_bottom - label_height - move_down;
% 
% label_MPI = uicontrol('Parent',panel, 'style','text', ...
%                  'units','pix', ...
%                  'position',[left_label , current_bottom , label_width , label_height], ...
%                  'backgroundc',get(fh,'color'), ...
%                  'fontsize',label_font_size,'fontweight','bold', ... 
%                  'HorizontalAlignment','left', ...
%                  'string','MPI inconsistency index');
% 
% %% calculate MPI inconsistency index or not
% 
% % current height of element
% current_height = radio_yes_no+radio_label;
% % current bottom coordinate
% current_bottom = current_bottom - current_height;
% calculate_MPI = uibuttongroup('Parent',panel, 'units','pix', ...
%     'title', 'Calculate', ...
%     'fontsize',font_size, ...
%     'pos',[left_other , current_bottom , element_width , current_height]);
% 
% calculate_MPI_choice(1) = uicontrol(calculate_MPI, ...
%     'value',MPI_flags(1), ...
%     'enable','on', ...
%     'style','rad', ...
%     'unit','pix', ...
%     'position',[yes_no_offsets(1) , radio_bottom , sub_element_width , radio_yes_no], ...
%     'fontsize',font_size, ...
%     'string',' YES');
% calculate_MPI_choice(2) = uicontrol(calculate_MPI, ...
%     'value',1-MPI_flags(1), ...
%     'enable','on', ...
%     'style','rad', ...
%     'unit','pix', ...
%     'position',[yes_no_offsets(2) , radio_bottom , sub_element_width , radio_yes_no], ...
%     'fontsize',font_size, ...
%     'string',' NO');
% 
% %% With or Without residuals
% enable_temp = enable{MPI_flags(1)+1};
% % current height of element
% current_height = radio_yes_no+radio_label;
% % current bottom coordinate
% current_bottom = current_bottom - current_height;
% residual_MPI = uibuttongroup('Parent',panel, 'units','pix', ...
%     'title', 'Residuals', ...
%     'fontsize',font_size, ...
%     'pos',[left_other , current_bottom , element_width , current_height]);
% 
% residual_MPI_choice(1) = uicontrol(residual_MPI, ...
%     'value',MPI_flags(2), ...
%     'enable',enable_temp, ...
%     'style','rad', ...
%     'unit','pix', ...
%     'position',[yes_no_offsets(1) , radio_bottom , sub_element_width , radio_yes_no], ...
%     'fontsize',font_size, ...
%     'string',' YES');
% residual_MPI_choice(2) = uicontrol(residual_MPI, ...
%     'value',1-MPI_flags(2), ...
%     'enable',enable_temp, ...
%     'style','rad', ...
%     'unit','pix', ...
%     'position',[yes_no_offsets(2) , radio_bottom , sub_element_width , radio_yes_no], ...
%     'fontsize',font_size, ...
%     'string',' NO');
% 
% %% In Sample and/or Out Of Sample
% enable_temp = enable{(MPI_flags(1)&&MPI_flags(2))+1};
% % current height of element
% current_height = radio_height+radio_label;
% % current bottom coordinate
% current_bottom = current_bottom - current_height;
% residual_MPI_options_group = uibuttongroup('Parent',panel, 'units','pix', ...
%     'title', 'Options', ...
%     'fontsize',font_size, ...
%     'pos',[left_other , current_bottom , element_width , current_height]);
% residual_MPI_options(1) = uicontrol(residual_MPI_options_group, ...
%     'value',MPI_flags(3), ...
%     'enable',enable_temp, ...
%     'style','rad', ...
%     'unit','pix', ...
%     'position',[radio_offset , radio_bottom , element_width , radio_height], ...
%     'string',' Out of Sample Calculation', ...
%     'fontsize',big_font_size);
% 
% 
% set(calculate_MPI_choice(:),'callback',{@MPI_calc_call})  % Set callback.
% set(residual_MPI_choice(:),'callback',{@MPI_rd_call})     % Set callback.

%% End of MPI settings





%% Power Test settings
% current bottom coordinate
current_bottom = panel_height-label_height-top_dist;   % current_bottom = current_bottom - move_down - label_height;
label_Power_Test = uicontrol('Parent',panel, ...
    'style','text', ...
    'units','pix', ...
    'position',[left_label+move_right , current_bottom , label_width , label_height], ...
    'backgroundc',get(fh,'color'), ...
    'fontsize',label_font_size,'fontweight','bold', ...
    'HorizontalAlignment','left', ...
    'string','Power Test'); %#ok<NASGU>

%% perform power test or not
if num_of_goods ~= 2
    % we currently only implement power test for 2 goods
    allow_power_test = 0;
    power_test_settings(1) = 0; 
else
    allow_power_test = 1;
end
% current bottom coordinate
current_bottom = current_bottom - (radio_yes_no+radio_label);
perform_power_test_group = uibuttongroup('Parent',panel, 'units','pix', ...
    'title', 'Perform', ...
    'fontsize',font_size, ...
    'pos',[left_other+move_right , current_bottom , element_width , radio_yes_no+radio_label]);

perform_power_test_choice(1) = uicontrol(perform_power_test_group, ...
    'value',power_test_settings(1), ...
    'enable',enable{1+allow_power_test}, ...
    'style','rad', ...
    'unit','pix', ...
    'position',[yes_no_offsets(1) , radio_bottom , sub_element_width , radio_yes_no], ...
    'fontsize',font_size, ...
    'string',' YES');
perform_power_test_choice(2) = uicontrol(perform_power_test_group, ...
    'value',1-power_test_settings(1), ...
    'enable',enable{1+allow_power_test}, ...
    'style','rad', ...
    'unit','pix', ...
    'position',[yes_no_offsets(2) , radio_bottom , sub_element_width , radio_yes_no], ...
    'fontsize',font_size, ...
    'string',' NO');

%% Number of Simulations for Power Test
% current height of element
current_height = label_height;
% current bottom coordinate
current_bottom = current_bottom - current_height - move_down;
% contianer
power_test_num_of_simulations_container = uibuttongroup('Parent',panel, 'units','pix', ...
    'pos',[left_other+move_right , current_bottom , element_width , radio_yes_no+radio_label-20]); %#ok<NASGU>
% label
power_test_num_of_simulations_label = uicontrol('Parent',panel, ...
    'style','text',...
    'units','pix',...
    'position',[left_other+move_right+10 , current_bottom+(current_height-text_height)-5 , 150 , current_height-7],...
    'backgroundc',get(fh,'color'),...
    'fontsize',big_font_size,...
    'string','Number of Simulations'); %#ok<NASGU>
% text input
power_test_num_of_simulations_input = uicontrol('Parent',panel, ...
    'style','edit',...
    'enable', enable{power_test_settings(1)+1},...
    'string',power_test_num_simulations_str,...
    'units','pix',...
    'position',[left_other+move_right+10+150 , current_bottom+current_height/2-5 , 80 , text_height],...
    'backgroundc','white',...
    'fontsize',big_font_size,...
    'callback',{@on_value_change_check_value_validity});

% whether the preferences are symmetric; we assume that is the case only in risk preferences 
symmetric_preferences = (pref_class == HPZ_Constants.risk_pref);

%% standard or given FOSD
% current bottom coordinate
current_bottom = current_bottom - (radio_yes_no+radio_label) - 5;
standard_or_given_FOSD_group = uibuttongroup('Parent',panel, 'units','pix', ...
    'title', 'Bundle Randomization type', ...
    'fontsize',font_size, ...
    'pos',[left_other+move_right , current_bottom , element_width , radio_yes_no+radio_label]);

standard_or_given_FOSD_choice(1) = uicontrol(standard_or_given_FOSD_group, ...
    'value',(~symmetric_preferences | ~power_test_settings(3)), ...
    'enable',enable{power_test_settings(1)*symmetric_preferences+1}, ...
    'style','rad', ...
    'unit','pix', ...
    'position',[yes_no_offsets(1) , radio_bottom , sub_element_width , radio_yes_no], ...
    'fontsize',font_size, ...
    'string',' Standard');
standard_or_given_FOSD_choice(2) = uicontrol(standard_or_given_FOSD_group, ...
    'value',~(~symmetric_preferences | ~power_test_settings(3)), ...
    'enable',enable{power_test_settings(1)*symmetric_preferences+1}, ...
    'style','rad', ...
    'unit','pix', ...
    'position',[yes_no_offsets(2) , radio_bottom , sub_element_width , radio_yes_no], ...
    'fontsize',font_size, ...
    'string',' Given FOSD');

% help button
standard_or_given_FOSD_help_button = uicontrol('Parent',panel, 'style','push', ...
    'unit','pix', ...
    'position',[left_other+element_width+move_right-23 , current_bottom+current_height , 20 , 20], ...
    'string','?', ...
    'fontsize',big_font_size, ...
    'callback',{@standard_or_given_FOSD_help_button_call}); %#ok<NASGU>

set(perform_power_test_choice(:),'callback',{@Power_Test_calc_call})     % Set callback.





%% AFRIAT settings

% current bottom coordinate (AFRIAT is at the bottom, to the right of GARP)
current_bottom = current_bottom - move_down - label_height;   % current_bottom = panel_height-label_height-top_dist;

label_AFRIAT = uicontrol('Parent',panel, 'style','text', ...
                 'units','pix', ...
                 'position',[left_label+move_right , current_bottom , label_width , label_height], ...
                 'backgroundc',get(fh,'color'), ...
                 'fontsize',label_font_size,'fontweight','bold', ... 
                 'HorizontalAlignment','left', ...
                 'string','AFRIAT inconsistency index'); %#ok<NASGU>

%% calculate AFRIAT inconsistency index or not
% current height of element
current_height = radio_yes_no+radio_label;
% current bottom coordinate
current_bottom = current_bottom - current_height;
calculate_AFRIAT = uibuttongroup('Parent',panel, 'units','pix', ...
    'title', 'Calculate', ...
    'fontsize',font_size, ...
    'pos',[left_other+move_right , current_bottom , element_width , current_height]);

calculate_AFRIAT_choice(1) = uicontrol(calculate_AFRIAT, ...
    'value',AFRIAT_flags(1), ...
    'enable','on', ...
    'style','rad', ...
    'unit','pix', ...
    'position',[yes_no_offsets(1) , radio_bottom , sub_element_width , radio_yes_no], ...
    'fontsize',font_size, ...
    'string',' YES');
calculate_AFRIAT_choice(2) = uicontrol(calculate_AFRIAT, ...
    'value',~AFRIAT_flags(1), ...
    'enable','on', ...
    'style','rad', ...
    'unit','pix', ...
    'position',[yes_no_offsets(2) , radio_bottom , sub_element_width , radio_yes_no], ...
    'fontsize',font_size, ...
    'string',' NO');

%% With or Without residuals
enable_temp = enable{AFRIAT_flags(1)+1};
% current height of element
current_height = radio_yes_no+radio_label;
% current bottom coordinate
current_bottom = current_bottom - current_height;
residual_AFRIAT = uibuttongroup('Parent',panel, 'units','pix', ...
    'title', 'Residuals', ...
    'fontsize',font_size, ...
    'pos',[left_other+move_right , current_bottom , element_width , current_height]);

residual_AFRIAT_choice(1) = uicontrol(residual_AFRIAT, ...
    'value',AFRIAT_flags(2), ...
    'enable',enable_temp, ...
    'style','rad', ...
    'unit','pix', ...
    'position',[yes_no_offsets(1) , radio_bottom , sub_element_width , radio_yes_no], ...
    'fontsize',font_size, ...
    'string',' YES');
residual_AFRIAT_choice(2) = uicontrol(residual_AFRIAT, ...
    'value',~AFRIAT_flags(2), ...
    'enable',enable_temp, ...
    'style','rad', ...
    'unit','pix', ...
    'position',[yes_no_offsets(2) , radio_bottom , sub_element_width , radio_yes_no], ...
    'fontsize',font_size, ...
    'string',' NO');

%% In Sample and/or Out Of Sample
enable_temp = enable{(AFRIAT_flags(1)&&AFRIAT_flags(2))+1};
% current height of element
current_height = radio_height+radio_label;
% current bottom coordinate
current_bottom = current_bottom - current_height;
residual_AFRIAT_options_group = uibuttongroup('Parent',panel, 'units','pix', ...
    'title', 'Options', ...
    'fontsize',font_size, ...
    'pos',[left_other+move_right , current_bottom , element_width , current_height]);
residual_AFRIAT_options(1) = uicontrol(residual_AFRIAT_options_group, ...
    'value',AFRIAT_flags(3), ...
    'enable',enable_temp, ...
    'style','rad', ...
    'unit','pix', ...
    'position',[radio_offset , radio_bottom , element_width , radio_height], ...
    'string',' Out of Sample Calculation', ...
    'fontsize',big_font_size);


set(calculate_AFRIAT_choice(:),'callback',{@AFRIAT_calc_call})  % Set callback.
set(residual_AFRIAT_choice(:),'callback',{@AFRIAT_rd_call})     % Set callback.

%% End of AFRIAT settings





%% HOUTMAN-MAKS settings

% current bottom coordinate (HOUTMAN-MAKS is just below VARIAN)
current_bottom = current_bottom - move_down;

% current bottom coordinate
current_bottom = current_bottom - label_height;
label_HOUTMAN = uicontrol('Parent',panel, 'style','text', ...
                 'units','pix', ...
                 'position',[left_label+move_right , current_bottom , label_width , label_height], ...
                 'backgroundc',get(fh,'color'), ...
                 'fontsize',label_font_size,'fontweight','bold', ... 
                 'HorizontalAlignment','left', ...
                 'string','HOUTMAN-MAKS inconsistency index'); %#ok<NASGU>

%% calculate HOUTMAN-MAKS inconsistency index or not
% current height of element
current_height = radio_yes_no+radio_label;
% current bottom coordinate
current_bottom = current_bottom - current_height;
calculate_HOUTMAN = uibuttongroup('Parent',panel, 'units','pix', ...
    'title', 'Calculate', ...
    'fontsize',font_size, ...
    'pos',[left_other+move_right , current_bottom , element_width , current_height]);

calculate_HOUTMAN_choice(1) = uicontrol(calculate_HOUTMAN, ...
    'value',HOUTMAN_flags(1), ...
    'enable','on', ...
    'style','rad', ...
    'unit','pix', ...
    'position',[yes_no_offsets(1) , radio_bottom , sub_element_width , radio_yes_no], ...
    'fontsize',font_size, ...
    'string',' YES');
calculate_HOUTMAN_choice(2) = uicontrol(calculate_HOUTMAN, ...
    'value',~HOUTMAN_flags(1), ...
    'enable','on', ...
    'style','rad', ...
    'unit','pix', ...
    'position',[yes_no_offsets(2) , radio_bottom , sub_element_width , radio_yes_no], ...
    'fontsize',font_size, ...
    'string',' NO');

%% With or Without residuals
enable_temp = enable{HOUTMAN_flags(1)+1};
% current height of element
current_height = radio_yes_no+radio_label;
% current bottom coordinate
current_bottom = current_bottom - current_height;
residual_HOUTMAN = uibuttongroup('Parent',panel, 'units','pix', ...
    'title', 'Residuals', ...
    'fontsize',font_size, ...
    'pos',[left_other+move_right , current_bottom , element_width , current_height]);

residual_HOUTMAN_choice(1) = uicontrol(residual_HOUTMAN, ...
    'value',HOUTMAN_flags(2), ...
    'enable',enable_temp, ...
    'style','rad', ...
    'unit','pix', ...
    'position',[yes_no_offsets(1) , radio_bottom , sub_element_width , radio_yes_no], ...
    'fontsize',font_size, ...
    'string',' YES');
residual_HOUTMAN_choice(2) = uicontrol(residual_HOUTMAN, ...
    'value',~HOUTMAN_flags(2), ...
    'enable',enable_temp, ...
    'style','rad', ...
    'unit','pix', ...
    'position',[yes_no_offsets(2) , radio_bottom , sub_element_width , radio_yes_no], ...
    'fontsize',font_size, ...
    'string',' NO');

set(calculate_HOUTMAN_choice(:),'callback',{@HOUTMAN_calc_call})    % Set callback.

%% End of HOUTMAN settings





%% VARIAN settings

% current bottom coordinate (AFRIAT is at the bottom, to the right of AFRIAT) 
current_bottom = panel_height-label_height-top_dist;
% % current bottom coordinate (VARIAN is at the bottom of AFRIAT)
% current_bottom = current_bottom - move_down - label_height;

label_VARIAN = uicontrol('Parent',panel, 'style','text', ...
                 'units','pix', ...
                 'position',[left_label+2*move_right , current_bottom , label_width , label_height], ...
                 'backgroundc',get(fh,'color'), ...
                 'fontsize',label_font_size,'fontweight','bold', ... 
                 'HorizontalAlignment','left', ...
                 'string','VARIAN inconsistency index'); %#ok<NASGU>

%% calculate VARIAN inconsistency index or not
% current height of element
current_height = radio_yes_no+radio_label;
% current bottom coordinate
current_bottom = current_bottom - current_height;
calculate_VARIAN = uibuttongroup('Parent',panel, 'units','pix', ...
    'title', 'Calculate', ...
    'fontsize',font_size, ...
    'pos',[left_other+2*move_right , current_bottom , element_width , current_height]);

calculate_VARIAN_choice(1) = uicontrol(calculate_VARIAN, ...
    'value',VARIAN_flags(1), ...
    'enable','on', ...
    'style','rad', ...
    'unit','pix', ...
    'position',[yes_no_offsets(1) , radio_bottom , sub_element_width , radio_yes_no], ...
    'fontsize',font_size, ...
    'string',' YES');
calculate_VARIAN_choice(2) = uicontrol(calculate_VARIAN, ...
    'value',~VARIAN_flags(1), ...
    'enable','on', ...
    'style','rad', ...
    'unit','pix', ...
    'position',[yes_no_offsets(2) , radio_bottom , sub_element_width , radio_yes_no], ...
    'fontsize',font_size, ...
    'string',' NO');

%% Which aggregators of Varian
% current height of element
current_height = radio_yes_no+radio_label;
% current bottom coordinate
current_bottom = current_bottom - current_height;
Varian_Aggregators = uibuttongroup('Parent',panel, 'units','pix', ...
    'title', 'Aggregators', ...
    'fontsize',font_size, ...
    'pos',[left_other+2*move_right , current_bottom , element_width , current_height]);

Varian_Aggregators_choice(1) = uicontrol(Varian_Aggregators, ...
    'value',VARIAN_flags(5), ...
    'enable',enable{2}, ...
    'style','check', ...
    'unit','pix', ...
    'position',[radio_offset+(extra_dist+sub_element_width)*0 , radio_bottom , sub_element_width , radio_yes_no], ...
    'fontsize',font_size, ...
    'string','Mean');
Varian_Aggregators_choice(2) = uicontrol(Varian_Aggregators, ...
    'value',VARIAN_flags(6), ...
    'enable',enable{2}, ...
    'style','check', ...
    'unit','pix', ...
    'position',[radio_offset+(extra_dist+sub_element_width)*1 , radio_bottom , sub_element_width , radio_yes_no], ...
    'fontsize',font_size, ...
    'string','AVG(SSQ)');
Varian_Aggregators_choice(3) = uicontrol(Varian_Aggregators, ...
    'value',VARIAN_flags(7), ...
    'enable',enable{2}, ...
    'style','check', ...
    'unit','pix', ...
    'position',[radio_offset+(extra_dist+sub_element_width)*2 , radio_bottom , sub_element_width , radio_yes_no], ...
    'fontsize',font_size, ...
    'string','Maximum');

%% With or Without residuals
enable_temp = enable{VARIAN_flags(1)+1};
% current height of element
current_height = radio_yes_no+radio_label;
% current bottom coordinate
current_bottom = current_bottom - current_height;
residual_VARIAN = uibuttongroup('Parent',panel, 'units','pix', ...
    'title', 'Residuals', ...
    'fontsize',font_size, ...
    'pos',[left_other+2*move_right , current_bottom , element_width , current_height]);

residual_VARIAN_choice(1) = uicontrol(residual_VARIAN, ...
    'value',VARIAN_flags(2), ...
    'enable',enable_temp, ...
    'style','rad', ...
    'unit','pix', ...
    'position',[yes_no_offsets(1) , radio_bottom , sub_element_width , radio_yes_no], ...
    'fontsize',font_size, ...
    'string',' YES');
residual_VARIAN_choice(2) = uicontrol(residual_VARIAN, ...
    'value',~VARIAN_flags(2), ...
    'enable',enable_temp, ...
    'style','rad', ...
    'unit','pix', ...
    'position',[yes_no_offsets(2) , radio_bottom , sub_element_width , radio_yes_no], ...
    'fontsize',font_size, ...
    'string',' NO');

%% In Sample and/or Out Of Sample
enable_temp = enable{(VARIAN_flags(1)&&VARIAN_flags(2))+1};
% current height of element
current_height = 3*radio_height+radio_label;
% current bottom coordinate
current_bottom = current_bottom - current_height;
residual_VARIAN_options_group = uibuttongroup('Parent',panel, 'units','pix', ...
    'title', 'Options', ...
    'fontsize',font_size, ...
    'pos',[left_other+2*move_right , current_bottom , element_width , current_height]);
residual_VARIAN_options(1) = uicontrol(residual_VARIAN_options_group, ...
    'value',(VARIAN_flags(3) && ~VARIAN_flags(4)), ...
    'enable',enable_temp, ...
    'style','rad', ...
    'unit','pix', ...
    'position',[radio_offset , radio_bottom+2*radio_height , element_width , radio_height], ...
    'string',' In Sample Calculation', ...
    'fontsize',big_font_size);
residual_VARIAN_options(2) = uicontrol(residual_VARIAN_options_group, ...
    'value',(~VARIAN_flags(3) && VARIAN_flags(4)), ...
    'enable',enable_temp, ...
    'style','rad', ...
    'unit','pix', ...
    'position',[radio_offset , radio_bottom+1*radio_height , element_width , radio_height], ...
    'string',' Out of Sample Calculation', ...
    'fontsize',big_font_size);
residual_VARIAN_options(3) = uicontrol(residual_VARIAN_options_group, ...
    'value',(VARIAN_flags(3) && VARIAN_flags(4)), ...
    'enable',enable_temp, ...
    'style','rad', ...
    'unit','pix', ...
    'position',[radio_offset , radio_bottom+0*radio_height , element_width , radio_height], ...
    'string',' Both', ...
    'fontsize',big_font_size);

set(calculate_VARIAN_choice(:),'callback',{@VARIAN_calc_call})  % Set callback.
set(Varian_Aggregators_choice(:),'callback',{@VARIAN_aggregator_call})  % Set callback.
set(residual_VARIAN_choice(:),'callback',{@VARIAN_rd_call})     % Set callback.

%% End of VARIAN settings





%% OK Button
ok_button = uicontrol('Parent',fh, 'style','push', ...
    'unit','pix', ...
    'position',[buttons_dists , (1-buttons_height)/2*buttons_space_height , (full_width-(buttons_num+1)*buttons_dists)/buttons_num , buttons_height*buttons_space_height], ...
    'string','OK', ...
    'fontsize',font_size, ...
    'callback',{@ok_button_call}); %#ok<NASGU>

%% Cancel Button
cancel_button = uicontrol('Parent',fh, 'style','push', ...
    'unit','pix', ...
    'position',[(full_width/2)+buttons_dists , (1-buttons_height)/2*buttons_space_height , (full_width-(buttons_num+1)*buttons_dists)/buttons_num , buttons_height*buttons_space_height], ...
    'string','Cancel', ...
    'fontsize',font_size, ...
    'callback',{@cancel_button_call}); %#ok<NASGU>





uiwait(fh)   % Prevent all other processes from starting until closed.





%% managing enable and disable when choosing to calculate GARP or not
function [] = GARP_calc_call(varargin)
    % Callback for pushbutton.

    if (get(calculate_GARP_choice(2),'value') == 1.0)
        % Not interested in calcualtion
        set(residual_GARP_choice(:), 'enable', 'off');
        set(residual_GARP_options(:), 'enable', 'off');
        set(which_residual_GARP_options(:), 'enable', 'off');
    else 
        set(residual_GARP_choice(:), 'enable', 'on');
        if (get(residual_GARP_choice(2),'value') == 0.0)
            set(residual_GARP_options(:), 'enable', 'on');
            set(which_residual_GARP_options(:), 'enable', 'on');
        end
    end
end

%% managing enable and disable when choosing with and without residuals in GARP
function [] = GARP_rd_call(varargin)
    % Callback for pushbutton.

    if (get(residual_GARP_choice(2),'value') == 1.0)
        % Not Interested in Residuals 
        set(residual_GARP_options(:), 'enable', 'off');
        set(which_residual_GARP_options(:), 'enable', 'off');
    else 
        set(residual_GARP_options(:), 'enable', 'on');
        set(which_residual_GARP_options(:), 'enable', 'on');
    end
end



%% MPI will be ready for the next version (version 4), currently not implemented 
% %% managing enable and disable when choosing to calculate MPI or not
% function [] = MPI_calc_call(varargin)
%     % Callback for pushbutton.
% 
%     if (get(calculate_MPI_choice(2),'value') == 1.0)
%         % Not interested in calcualtion
%         set(residual_MPI_choice(:), 'enable', 'off');
%         set(residual_MPI_options(:), 'enable', 'off');
%     else 
%         set(residual_MPI_choice(:), 'enable', 'on');
%         if (get(residual_MPI_choice(2),'value') == 0.0)
%             set(residual_MPI_options(:), 'enable', 'on');
%         end
%     end
% end
% 
% %% managing enable and disable when choosing with and without residuals in MPI
% function [] = MPI_rd_call(varargin)
%     % Callback for pushbutton.
% 
%     if (get(residual_MPI_choice(2),'value') == 1.0)
%         % Not Interested in Residuals 
%         set(residual_MPI_options(:), 'enable', 'off');
%     else 
%         set(residual_MPI_options(:), 'enable', 'on');
%     end
% end


%% managing enable and disable when choosing to perform Power Test or not
function [] = Power_Test_calc_call(varargin)
    % Callback for pushbutton.

    if (get(perform_power_test_choice(2),'value') == 1.0)
        % Not interested in calcualtion
        set(power_test_num_of_simulations_input, 'enable', 'off');
        set(standard_or_given_FOSD_choice(:), 'enable', 'off');
    else 
        % interested in calculation
        set(power_test_num_of_simulations_input, 'enable', 'on');
        if symmetric_preferences
            set(standard_or_given_FOSD_choice(:), 'enable', 'on');
        end
    end
    
    
    
end

%% managing enable and disable when choosing to calculate AFRIAT or not
function [] = AFRIAT_calc_call(varargin)
    % Callback for pushbutton.

    if (get(calculate_AFRIAT_choice(2),'value') == 1.0)
        % Not interested in calcualtion
        set(residual_AFRIAT_choice(:), 'enable', 'off');
        set(residual_AFRIAT_options(:), 'enable', 'off');
    else 
        set(residual_AFRIAT_choice(:), 'enable', 'on');
        if (get(residual_AFRIAT_choice(2),'value') == 0.0)
            set(residual_AFRIAT_options(:), 'enable', 'on');
        end
    end
end

%% managing enable and disable when choosing with and without residuals in AFRIAT
function [] = AFRIAT_rd_call(varargin)
    % Callback for pushbutton.

    if (get(residual_AFRIAT_choice(2),'value') == 1.0)
        % Not Interested in Residuals 
        set(residual_AFRIAT_options(:), 'enable', 'off');
    else 
        set(residual_AFRIAT_options(:), 'enable', 'on');
    end
end



%% managing enable and disable when choosing to calculate VARIAN or not
function [] = VARIAN_calc_call(varargin)
    % Callback for pushbutton.

    if (get(calculate_VARIAN_choice(2),'value') == 1.0)
        % Not interested in calcualtion
        set(residual_VARIAN_choice(:), 'enable', 'off');
        set(residual_VARIAN_options(:), 'enable', 'off');
    else 
        set(residual_VARIAN_choice(:), 'enable', 'on');
        if (get(residual_VARIAN_choice(2),'value') == 0.0)
            set(residual_VARIAN_options(:), 'enable', 'on');
        end
    end
end

%% managing enable and disable when choosing with and without residuals in VARIAN
function [] = VARIAN_rd_call(varargin)
    % Callback for pushbutton.

    if (get(residual_VARIAN_choice(2),'value') == 1.0)
        % Not Interested in Residuals 
        set(residual_VARIAN_options(:), 'enable', 'off');
    else 
        set(residual_VARIAN_options(:), 'enable', 'on');
    end
end

%% making sure at least one aggregator of Varian is marked
function [] = VARIAN_aggregator_call(varargin)
    % Callback for pushbutton.
    
    % which Varian aggregators to calculate and print (Mean, AVG(SSQ), Maximum)  
    Varian_aggregator_flags = cell2mat(get(Varian_Aggregators_choice(:), 'value'));
    if sum(Varian_aggregator_flags) == 0
       % arbitrarily set the first (Mean) as marked 
       set(Varian_Aggregators_choice(1), 'value', 1.0);
    end
end



%% managing enable and disable when choosing to calculate HOUTMAN-MAKS or not
function [] = HOUTMAN_calc_call(varargin)
    % Callback for pushbutton.

    if (get(calculate_HOUTMAN_choice(2),'value') == 1.0)
        % Not interested in calcualtion
        set(residual_HOUTMAN_choice(:), 'enable', 'off');
    else 
        set(residual_HOUTMAN_choice(:), 'enable', 'on');
    end
end





%% making sure the number of simulations in Power Test is an eligible number   
function [] = on_value_change_check_value_validity(varargin)
    
    % arbitrary boundaries to the number of simulations
    min_num_simulations = 100;
    max_num_simulations = 1000000;
    
    previous_power_test_num_simulations_str = power_test_num_simulations_str;
    power_test_num_simulations_str = get(power_test_num_of_simulations_input,'string');
    if ~all(ismember(power_test_num_simulations_str, 'Ee+^1234567890')) || isempty(str2num(power_test_num_simulations_str)) %#ok<ST2NM>
        % the user entered something that is not a number
        power_test_num_simulations_str = previous_power_test_num_simulations_str;
        set(power_test_num_of_simulations_input,'string',power_test_num_simulations_str);
    elseif str2double(power_test_num_simulations_str) < min_num_simulations
        power_test_num_simulations_str = num2str(min_num_simulations);
        set(power_test_num_of_simulations_input,'string',power_test_num_simulations_str);
    elseif str2double(power_test_num_simulations_str) > max_num_simulations
        power_test_num_simulations_str = num2str(max_num_simulations);
        set(power_test_num_of_simulations_input,'string',power_test_num_simulations_str);
    end
end





%% OK button
function [] = ok_button_call(varargin)
    % Callback for ok button.

    ok = 1;

    % Instead of switch, we could use num2str on:
    % find(get(bg,'selectedobject')==rd)      (or similar)
    % Note the use of findobj.  This is because of a BUG in MATLAB, whereby if
    % the user selects the same button twice, the selectedobject property will
    % not work correctly.
    
    %% choices regarding Revealed Preference Graphs
    % which graphs to plot and save
    Graph_flags_temp = cell2mat(get(RP_Graph_choice(:), 'value'));
    Graph_flags(1:4) = Graph_flags_temp';
    % options (weights on edges in graphs)
    switch findobj(get(RP_Graph_option,'selectedobject'))
        case RP_Graph_options(1)
            Graph_flags(5) = 0;
        case RP_Graph_options(2)
            Graph_flags(5) = 1;
    end
    
    
    
    %% choices regarding Power Test
    
    perform_power_test_flag = nan;
    
    switch findobj(get(perform_power_test_group,'selectedobject'))
        case perform_power_test_choice(1)
            % perform power test
            perform_power_test_flag = 1;

        case perform_power_test_choice(2)
            % don't perform power test
            perform_power_test_flag = 0;
    end
    
    num_simulations_power_test = str2num(get(power_test_num_of_simulations_input,'string')); %#ok<ST2NM>
    
    standard_or_given_FOSD_flag = nan;
    
    switch findobj(get(standard_or_given_FOSD_group,'selectedobject'))
        case standard_or_given_FOSD_choice(1)
            % standard
            standard_or_given_FOSD_flag = 0;

        case standard_or_given_FOSD_choice(2)
            % given FOSD
            standard_or_given_FOSD_flag = 1;
    end
    
    power_test_settings = [perform_power_test_flag , num_simulations_power_test , standard_or_given_FOSD_flag];
    
    
    
    %% choices regarding GARP WARP and SARP

    GARP_calculate_flag = 0;
    GARP_residual_flag = 0;
    GARP_in_sample_flag = 0;
    GARP_out_sample_flag = 0;
    WARP_res = 0;
    GARP_res = 0;
    SARP_res = 0;

    switch findobj(get(calculate_GARP,'selectedobject'))
        case calculate_GARP_choice(1)
            % with residuals
            GARP_calculate_flag = 1;

        case calculate_GARP_choice(2)
            % without residuals
            GARP_calculate_flag = 0;
    end

    switch findobj(get(residual_GARP,'selectedobject'))
        case residual_GARP_choice(1)
            % with residuals
            GARP_residual_flag = 1;

        case residual_GARP_choice(2)
            % without residuals
            GARP_residual_flag = 0;
    end

    % in and out of sample
    %if ~(get(residual_GARP_choice(2),'value') == 1.0)
    if get(residual_GARP_options(1), 'value') == 1.0
        GARP_in_sample_flag = 1;
    elseif get(residual_GARP_options(2), 'value') == 1.0
        GARP_out_sample_flag = 1;
    elseif get(residual_GARP_options(3), 'value') == 1.0
        GARP_in_sample_flag = 1;
        GARP_out_sample_flag = 1;
    end
    %end

    % which residuals (WARP / GARP / SARP)
    %if ~(get(residual_GARP_choice(2),'value') == 1.0)
    if get(which_residual_GARP_options(1), 'value') == 1.0
        WARP_res = 1;
    elseif get(which_residual_GARP_options(2), 'value') == 1.0
        GARP_res = 1;
    elseif get(which_residual_GARP_options(3), 'value') == 1.0
        SARP_res = 1;
    elseif get(which_residual_GARP_options(4), 'value') == 1.0
        WARP_res = 1;
        GARP_res = 1;
        SARP_res = 1;
    end
    %end

    GARP_flags = [GARP_calculate_flag , GARP_residual_flag , GARP_in_sample_flag , GARP_out_sample_flag, WARP_res, GARP_res, SARP_res];


    %% choices regarding MPI consistency index

    MPI_calculate_flag = 0;
    MPI_residual_flag = 0;
    MPI_in_sample_flag = 0;
    MPI_out_sample_flag = 0;

    % MPI will be ready for the next version (version 3), currently not implemented 
%     switch findobj(get(calculate_MPI,'selectedobject'))
%         case calculate_MPI_choice(1)
%             % with residuals
%             MPI_calculate_flag = 1;
% 
%         case calculate_MPI_choice(2)
%             % without residuals
%             MPI_calculate_flag = 0;
%     end
% 
%     switch findobj(get(residual_MPI,'selectedobject'))
%         case residual_MPI_choice(1)
%             % with residuals
%             MPI_residual_flag = 1;
% 
%         case residual_MPI_choice(2)
%             % without residuals
%             MPI_residual_flag = 0;
%     end
% 
%     % in and out of sample (only out of sample is relevant to MPI) 
%     %if ~(get(residual_MPI_choice(2),'value') == 1.0)
%     if get(residual_MPI_options(1), 'value') == 1.0
%         MPI_out_sample_flag = 1;
%     end
%     %end

    MPI_flags = [MPI_calculate_flag , MPI_residual_flag , MPI_in_sample_flag , MPI_out_sample_flag];

    
    %% choices regarding AFRIAT consistency index

    AFRIAT_calculate_flag = 0;
    AFRIAT_residual_flag = 0;
    AFRIAT_in_sample_flag = 0;
    AFRIAT_out_sample_flag = 0;

    switch findobj(get(calculate_AFRIAT,'selectedobject'))
        case calculate_AFRIAT_choice(1)
            % with residuals
            AFRIAT_calculate_flag = 1;

        case calculate_AFRIAT_choice(2)
            % without residuals
            AFRIAT_calculate_flag = 0;
    end

    switch findobj(get(residual_AFRIAT,'selectedobject'))
        case residual_AFRIAT_choice(1)
            % with residuals
            AFRIAT_residual_flag = 1;

        case residual_AFRIAT_choice(2)
            % without residuals
            AFRIAT_residual_flag = 0;
    end

    % in and out of sample (only out of sample is relevant to AFRIAT) 
    if ~(get(residual_AFRIAT_choice(2),'value') == 1.0)
        if get(residual_AFRIAT_options(1), 'value') == 1.0
            AFRIAT_out_sample_flag = 1;
        end
    end

    AFRIAT_flags = [AFRIAT_calculate_flag , AFRIAT_residual_flag , AFRIAT_in_sample_flag , AFRIAT_out_sample_flag];


    %% choices regarding VARIAN consistency index

    VARIAN_calculate_flag = 0;
    VARIAN_residual_flag = 0;
    VARIAN_in_sample_flag = 0;
    VARIAN_out_sample_flag = 0;

    switch findobj(get(calculate_VARIAN,'selectedobject'))
        case calculate_VARIAN_choice(1)
            % with residuals
            VARIAN_calculate_flag = 1;

        case calculate_VARIAN_choice(2)
            % without residuals
            VARIAN_calculate_flag = 0;
    end

    switch findobj(get(residual_VARIAN,'selectedobject'))
        case residual_VARIAN_choice(1)
            % with residuals
            VARIAN_residual_flag = 1;

        case residual_VARIAN_choice(2)
            % without residuals
            VARIAN_residual_flag = 0;
    end

    %if ~(get(residual_VARIAN_choice(2),'value') == 1.0)
    % in and out of sample
    if get(residual_VARIAN_options(1), 'value') == 1.0
        VARIAN_in_sample_flag = 1;
        VARIAN_out_sample_flag = 0;
    elseif get(residual_VARIAN_options(2), 'value') == 1.0
        VARIAN_in_sample_flag = 0;
        VARIAN_out_sample_flag = 1;
    elseif get(residual_VARIAN_options(3), 'value') == 1.0
        VARIAN_in_sample_flag = 1;
        VARIAN_out_sample_flag = 1;
    end
    %end
    
    % which Varian aggregators to calculate and print (Mean, AVG(SSQ), Maximum)  
    Varian_aggregator_flags = cell2mat(get(Varian_Aggregators_choice(:), 'value'));
    Varian_aggregator_flags = Varian_aggregator_flags';

    VARIAN_flags = [VARIAN_calculate_flag , VARIAN_residual_flag , VARIAN_in_sample_flag , VARIAN_out_sample_flag , Varian_aggregator_flags];


    %% choices regarding HOUTMAN-MAKS inconsistency index

    HOUTMAN_calculate_flag = 0;
    HOUTMAN_residual_flag = 0;

    switch findobj(get(calculate_HOUTMAN,'selectedobject'))
        case calculate_HOUTMAN_choice(1)
            % with residuals
            HOUTMAN_calculate_flag = 1;

        case calculate_HOUTMAN_choice(2)
            % without residuals
            HOUTMAN_calculate_flag = 0;
    end

    switch findobj(get(residual_HOUTMAN,'selectedobject'))
        case residual_HOUTMAN_choice(1)
            % with residuals
            HOUTMAN_residual_flag = 1;

        case residual_HOUTMAN_choice(2)
            % without residuals
            HOUTMAN_residual_flag = 0;
    end

    % these 2 flags are only for consistency with the other indices
    HOUTMAN_in_sample_flag = 0;
    HOUTMAN_out_sample_flag = HOUTMAN_residual_flag;
    
    HOUTMAN_flags = [HOUTMAN_calculate_flag , HOUTMAN_residual_flag , HOUTMAN_in_sample_flag , HOUTMAN_out_sample_flag];

    
    % write the current setting to the settings file to be saved for next time  
    HPZ_Consistency_Indices_Settings_Write(Graph_flags, power_test_settings, GARP_flags, AFRIAT_flags, VARIAN_flags, HOUTMAN_flags, MPI_flags, main_folder);
    

    %% close the window
    close(fh);

end



%% Cancel button
function [] = cancel_button_call(varargin)
    % Callback for Cancel button.
    ok = 0;

    % close the window
    close(fh);
end



function [] = help_button_1_call(varargin)
    msgbox({'Whether to create Graphs that represent the revealed preference relations as edges, and the observations as nodes.', ...
                '','Problem is, showing ALL such relations will yield a graph with too many edges, which will make it unuseful.', ...
                '','We suggest to drop some of the edges and thus create a more informative graph, in 4 ways:', ...
                '','1. If the subject is completely consistent, one may want to create a graph that shows the hierarchy between the chosen bundles, thus if (8,8)->(6,6)->(4,4), we can drop the direct edge (8,8)->(4,4).', ...
                '','2. If the subject is completely consistent, one may want to create a graph that shows the hierarchy between the observations, thus if a->b->c, we can drop the direct edge a->c.', ...
                '','3. If the subject is inconsistent, we can focus only on edges that are part of cycles that violate the axioms of revealed preference.', ...
                '','4. If the subject is inconsistent, we can focus only on edges that are part of minimal cycles that violate the axioms of revealed preference. Minimal cycles have their importance, both intuitively, and because HM-index depends solely on them.'});
end
function [] = help_button_2_call(varargin)
    msgbox({'When Creating a Graph that represents RP, such that revealed preference relations are represented as edges, what should the weights of the edges be?', ...
                '','1. No weights; If a revealed preference relation is Strict - the edge will be thick, if it is weak (non-strict) - the edge will be thin', ...
                '','2. Assign a weight that equals to 1-v, when v is the Afriat and Varian Multiplier, e.g. if v is 0.79, then by multiplying observation i by q<0.79, the i->j relation will be broken', ...
                '','Note that the 2nd option is only used when the subject is inconsistent (since in hierarchy graphs we arbitrarily drop revealed preference relations).'});
end
function [] = standard_or_given_FOSD_help_button_call(varargin)
    msgbox({'If the Decision Maker needs to choose between two arrow goods with 50% winning chance for each, as in the risk preferences currently implemented, the two goods are symmetric, therefore any choice in which the chosen quantity of the the more expensive good is greater than the chosen quantity of the the cheaper good, is irrational.', ...
                '','Hence, it makes more sense to randomize the bundles in the simulations only on the part of the budget line that contains bundles that are not First-Order-Stochastically-Dominated (FOSD) by other bundles in the budget set.', ...
                'This is what the "Given FOSD" option is for.', ...
                'If you would like the randomization to choose randomly over all the budget line, use "Standard".', ...
                '(P.S. all randomizations use uniform distribution)', ...
                '','One may use this also when having another case of two symmetric goods. In this case, you will need to define the dataset as "risk preferences" to allow for this options, even if those are not actually the preferences.'});
end



    
end % end of function